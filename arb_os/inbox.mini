//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use std::queue::Queue;
use std::queue::queue_new;
use std::queue::queue_isEmpty;
use std::queue::queue_get;
use std::queue::queue_put;
use std::queue::QueueStack;
use std::queue::queuestack_new;
use std::queue::queuestack_push;
use std::queue::queuestack_get;

use accounts::safeGetGlobalAccountStore;
use accounts::safeSetGlobalAccountStore;
use accounts::accountStore_get;
use accounts::accountStore_set;
use accounts::account_addToEthBalance;
use accounts::account_checkAndIncrSeqNum;

use blockhash::blockhash_submitHash;

use chainParameters::chainParams_gotParamsMessage;
use chainParameters::chainParams_chainId;

use evmlogs::EvmLogs;

use gasAccounting::GasUsage;
use gasAccounting::allowedSenders_contains;
use gasAccounting::gasAccounting_prepareTx;
use gasAccounting::updateL1GasPriceEstimate;
use gasAccounting::txFeeStats_zero;

use messages::TxRequestData;
use messages::processL2Request;

use messageBatch::messageBatch_tryNew;
use messageBatch::messageBatch_get;

use output::outputStats_endOfBlock;
use output::emitTxReceipt;

use retrybuffer::RetryableTx;
use retrybuffer::processRetryableTx;

use std::bytearray::ByteArray;
use std::bytearray::bytearray_size;
use std::bytearray::bytearray_fromSizeAndBuffer;
use std::bytearray::bytearray_getByte;
use std::bytearray::bytearray_get256;
use std::bytearray::bytearray_getCalldataUnits;

use std::bytestream::bytestream_new;
use std::bytestream::bytestream_getByte;
use std::bytestream::bytestream_get256;
use std::bytestream::bytestream_getRemainingBytes;

use std::keccak::keccak256;

use decompression::decompressAndVerifyEcdsaSignedTx;
use decompression::decompressAndVerifyBLSSignedTxBatch;


type Inbox = struct {
    queue: IncomingRequestQueue,    // queue of requests that haven't yet been retrieved from the inbox
    arbBlockNum: uint,              // highest Arbitrum blocknum of messages that have been retrieved from the inbox
    ethBlockNum: uint,              // highest L1 blocknum of messages that have been retrieved from the inbox
    timestamp: uint,                // highest timestamp of messages that have been retrieved from the inbox
    atStartOfBlock: bool,           // true iff we should start a new Arbitrum block when the next message arrives
    inboxHashAccumulator: bytes32,  // hash accumulator covering all inbox messages so far
    pendingMessage: option<IncomingRequest>,  // message being held until sideloads have had a chance to be processed
}

var globalInbox: Inbox;
var globalInputQueue: struct {
    txQ: TxRequestQueue,
    batchQ: IncomingRequestQueueStack,
};

public impure func inbox_init() {
    globalInbox = struct {
        queue: incomingRequestQueue_new(),
        arbBlockNum: 0,
        ethBlockNum: 0,
        timestamp: 0,
        atStartOfBlock: true,
        inboxHashAccumulator: bytes32(0),
        pendingMessage: None<IncomingRequest>,
    };
    globalInputQueue = struct {
        txQ: txRequestQueue_new(),
        batchQ: incomingRequestQueueStack_new()
    };
}

public impure func emitGenesisBlockReceipt() {
    outputStats_endOfBlock(globalInbox.arbBlockNum, globalInbox.ethBlockNum, globalInbox.timestamp);
    blockhash_submitHash(globalInbox.ethBlockNum, globalInbox.inboxHashAccumulator);
    set globalInbox.arbBlockNum = globalInbox.arbBlockNum + 1;
}

public impure func inbox_get() -> IncomingRequest {
    // Get the next message, in order of arrival.
    // If no messages have arrived, this will block until one arrives.
    // This is a loop because some events don't generate a message that we can return,
    //       so we keep trying until we find something we can return.

    return xloop {
        while (incomingRequestQueue_isEmpty(globalInbox.queue)) {
            globalInbox = getFromL1Inbox(globalInbox);
        }

        let (updatedQ, rawMsg) = incomingRequestQueue_getOrDie(globalInbox.queue);
        set globalInbox.queue = updatedQ ;
        let ebMsg = unsafecast<IncomingRequest>(rawMsg);

        let ebMsgHash = hashIncomingRequest(ebMsg);
        set globalInbox.inboxHashAccumulator = hash(globalInbox.inboxHashAccumulator, ebMsgHash);

        if (ebMsg.kind == const::L1MessageType_setChainParameters) {
            if (ebMsg.sender == address(0)) {
                chainParams_gotParamsMessage(ebMsg.msgData);
            }   // ignore this message if it didn't come from address zero
            // loop back to get the next message
        } else {
            set ebMsg.requestId = uint(hash(bytes32(chainParams_chainId()), bytes32(ebMsg.requestId)));
            return ebMsg;
        }
    };
}

// translate a newly arrived message from the incoming format into the format we'll use internally
impure func incomingRequestFromRaw(newMsgRaw: IncomingRequestFromInbox, fromSideload: bool) -> IncomingRequest {
    if (! fromSideload) {
        updateL1GasPriceEstimate(newMsgRaw.sender, newMsgRaw.gasPriceL1);
    }

    if (newMsgRaw.ethBlockNumber < globalInbox.ethBlockNum) {
        // enforce non-decreasing property of Ethereum block numbers on incoming messages
        set newMsgRaw.ethBlockNumber = globalInbox.ethBlockNum;
    }
    if (newMsgRaw.timestamp < globalInbox.timestamp) {
        // enforce non-decreasing property of timestamps on incoming messages
        set newMsgRaw.timestamp = globalInbox.timestamp;
    }

    return struct {
        kind: newMsgRaw.kind,
        arbBlockNumber: globalInbox.arbBlockNum,    // assign the current Arbitrum block number
        ethBlockNumber: newMsgRaw.ethBlockNumber,
        timestamp: newMsgRaw.timestamp,
        sender: newMsgRaw.sender,
        requestId: newMsgRaw.requestId,
        msgData: bytearray_fromSizeAndBuffer(newMsgRaw.msgSize, newMsgRaw.msgData),
        provenance: struct {
            l1SeqNum: newMsgRaw.requestId,
            parentRequestId: 0,
            indexInParent: ~0,
        },
        aggregator: None<AggregatorInfo>,
        adminMode: fromSideload && (newMsgRaw.kind != const::L1MessageType_L2ForGasEstimation),
        gasEstimationParams: None<GasEstimationParams>,
    };
}

#[noinline, ] impure func getFromL1Inbox(inbox: Inbox) -> Inbox {
    // Get a message from the L1 inbox, and append it to the inbox.
    // Automatically generate an end-of-block message if that is needed.
    // If there are no messages available in the L1 inbox, this blocks until one is available

    if let Some(pendingMsg) = inbox.pendingMessage {
        // There is a pending message, so we need to handle any sideloads before proceeding.
        // Sideloads are method that nodes can use to inject messages into their private copy of the AVM state.
        // In the "on chain" AVM, a sideload instruction always returns (), but a node can make it return something
        //      else, to get the node's private copy of the chain state to process some other message.
        // At the end of each block, ArbOS will process as many sideloaded messages as it is given, until a sideload
        //      returns (). Then ArbOS will go on to process the messages from the new L1 block.
        let rawSideloadMsg = asm(inbox.arbBlockNum) any { sideload };
        if (rawSideloadMsg != ()) {
            // a sideloaded message was received, so enqueue it for processing
            let newMsg = incomingRequestFromRaw(unsafecast<IncomingRequestFromInbox>(rawSideloadMsg), true);
            return inbox with {
                queue: incomingRequestQueue_put(inbox.queue, newMsg)
            };
        }

        // there are no more sideloads for this block, so do end of block processing
        outputStats_endOfBlock(inbox.arbBlockNum, inbox.ethBlockNum, inbox.timestamp);
        blockhash_submitHash(inbox.ethBlockNum, inbox.inboxHashAccumulator);

        set inbox.pendingMessage = None<IncomingRequest>;
        set inbox.arbBlockNum = inbox.arbBlockNum + 1;
        set inbox.ethBlockNum = pendingMsg.ethBlockNumber;
        set inbox.timestamp = pendingMsg.timestamp;

        return xif (pendingMsg.kind != const::L1MessageType_endOfBlock) {
            // enqueue the pending message for processing
            inbox with {
                queue: incomingRequestQueue_put(
                    inbox.queue,
                    pendingMsg with { arbBlockNumber: pendingMsg.arbBlockNumber + 1 },
                )
            }
        } else {
            inbox with {
                atStartOfBlock: true
            }
        };
    }

    let newMsg = incomingRequestFromRaw(asm() IncomingRequestFromInbox { inbox }, false);
    if ( (!inbox.atStartOfBlock) && ((newMsg.ethBlockNumber > inbox.ethBlockNum) || (newMsg.timestamp > inbox.timestamp)) ){
        set inbox.pendingMessage = Some(newMsg);
    } elseif (newMsg.kind == const::L1MessageType_endOfBlock) {
        if ( ! inbox.atStartOfBlock) {
            set inbox.pendingMessage = Some(newMsg);
        }
    } else {
        set inbox.queue = incomingRequestQueue_put(inbox.queue, newMsg);
        set inbox.ethBlockNum = newMsg.ethBlockNumber;
        set inbox.arbBlockNum = newMsg.arbBlockNumber;
        set inbox.timestamp = newMsg.timestamp;
        set inbox.atStartOfBlock = false;
    }
    return inbox;
}

public impure func inbox_currentTimestamp() -> uint {
    return globalInbox.timestamp;
}

public impure func inbox_currentArbBlockNumber() -> uint {
    return globalInbox.arbBlockNum;
}

public impure func inbox_currentEthBlockNumber() -> uint {
    return globalInbox.ethBlockNum;
}

type IncomingRequestFromInbox = struct {
    kind: uint,               // type of message
    ethBlockNumber: uint,     // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,          // unique value assigned by the L1 inbox contract
    gasPriceL1: uint,         // L1 gas price paid by this tx
    msgSize: uint,            // size of payload message
    msgData: buffer,          // payload message data
}

type IncomingRequest = struct {
    kind: uint,               // type of message
    arbBlockNumber: uint,     // Arbitrum block number
    ethBlockNumber: uint,     // block number of the L1 block
    timestamp: uint,          // timestamp of the L1 block
    sender: address,          // address of the sender
    requestId: uint,          // unique identifier for this request
    msgData: ByteArray,       // kind-specific data
    provenance: RequestProvenance,
    aggregator: option<AggregatorInfo>,
    adminMode: bool,          // true iff this is a sideloaded message inserted for private execution by a node
    gasEstimationParams: option<GasEstimationParams>,  // used if this is a gas estimation message
}

type GasEstimationParams = struct {
    computeGasLimit: uint,
    ignoreGasPrice: bool,
    ignoreMaxGas: bool,
}

type RequestProvenance = struct {
    l1SeqNum: uint,
    parentRequestId: uint,
    indexInParent: uint,
}

type AggregatorInfo = struct {
    aggregator: option<address>,
    calldataUnits: uint,
}

func hashIncomingRequest(req: IncomingRequest) -> bytes32 {  // a convenient hash over some fields of a request
    return hash(
        bytes32(req.kind),
        hash(
            bytes32(req.arbBlockNumber),
            hash(
                bytes32(req.ethBlockNumber),
                hash(
                    bytes32(req.timestamp),
                    hash(
                        bytes32(req.sender),
                        hash(
                            bytes32(req.requestId),
                            keccak256(req.msgData, 0, bytearray_size(req.msgData)),
                        )
                    )
                )
            )
        )
    );
}

public impure func mainRunLoop() {
    loop {
        if let Some(res) = txRequestQueue_get(globalInputQueue.txQ) {   // consume from txQ first
            let (newQ, tx) = res;
            globalInputQueue = globalInputQueue with {
                txQ: newQ
            };
            handleArrivingTx(unsafecast<TxRequestData>(tx));
        } else {
            let msg = xif let Some(res) = incomingRequestQueueStack_get(globalInputQueue.batchQ) {  // consume from batchQ second
                let (newQ, umsg) = res;
                globalInputQueue = globalInputQueue with {
                    batchQ: newQ
                };
                umsg
            } else {
                inbox_get()   // the queues are empty, so get the next message from the inbox
            };

            if let Some(batch) = messageBatch_tryNew(msg) {
                // it's a batch message, so unpack all of its component requests and put them in the batchQ
                let moreToDo = true;
                let queue = incomingRequestQueue_new();
                while (moreToDo) {
                    if let Some(res) = messageBatch_get(batch) {
                        let (newMsg, *batch) = res;
                        queue = incomingRequestQueue_put(queue, newMsg);
                    } else {
                        moreToDo = false;
                    }
                }
                set globalInputQueue.batchQ = incomingRequestQueueStack_push(globalInputQueue.batchQ, queue);
            } elseif (    (msg.kind == const::L1MessageType_L2 || msg.kind == const::L1MessageType_L2ForGasEstimation)
                       && (bytearray_getByte(msg.msgData, 0) == const::L2MessageType_blsBatch) ) {
               if let Some(updatedQ) = decompressAndVerifyBLSSignedTxBatch(
                    msg.msgData,
                    msg,
                    unsafecast<Queue>(globalInputQueue.txQ)
                ) {
                    set globalInputQueue.txQ = unsafecast<TxRequestQueue>(updatedQ);
                }
                // else BLS batch was bad, so ignore it
            } else {
                handleUnpackedMessage(msg);
            }
        }
    }
}

impure func handleUnpackedMessage(msg: IncomingRequest) {
    if (msg.kind == const::L1MessageType_L2FundedByL1) {
        // record the calldata usage, so it can be reported in tx receipt
        set msg.aggregator = Some(struct {
            aggregator: None<address>,
            calldataUnits: bytearray_getCalldataUnits(msg.msgData),
        });

        // the message carries an ETH deposit
        // verify the validity of the message, process the deposit, then process the tx
        let firstByte = bytearray_getByte(msg.msgData, 0);
        if (firstByte == const::L2MessageType_unsignedEOATx) {
            let callvalue = bytearray_get256(msg.msgData, 1+4*32);
            let gAcctStore = safeGetGlobalAccountStore();
            safeSetGlobalAccountStore(
                accountStore_set(
                    gAcctStore,
                    msg.sender,
                    account_addToEthBalance(accountStore_get(gAcctStore, msg.sender), callvalue)
                )
            );
            if let Some(txRequest) = translateUnsignedTx(msg) {
                handleArrivingTx(txRequest);
            }
            // else request was malformatted, ignore it but don't undo the deposit
        } elseif (firstByte == const::L2MessageType_unsignedContractTx) {
            let callvalue = bytearray_get256(msg.msgData, 1+3*32);
            let gAcctStore = safeGetGlobalAccountStore();
            safeSetGlobalAccountStore(
                accountStore_set(
                    gAcctStore,
                    msg.sender,
                    account_addToEthBalance(accountStore_get(gAcctStore, msg.sender), callvalue)
                )
            );
            if let Some(txRequest) = translateUnsignedTx(msg) {
                handleArrivingTx(txRequest);
            }
            // else request was malformatted, ignore it but don't undo the deposit
        }
        // else L2 msg type is invalid in ETH deposit message, ignore msg
        //      note that deposit doesn't happen in this case
    } elseif (msg.kind == const::L1MessageType_endOfBlock) {
        // it's an end-of-block message, so just trigger end-of-block processing
        outputStats_endOfBlock(msg.arbBlockNumber, msg.ethBlockNumber, msg.timestamp);
        blockhash_submitHash(msg.ethBlockNumber, globalInbox.inboxHashAccumulator);
        set globalInbox.arbBlockNum = globalInbox.arbBlockNum + 1;
    } elseif (msg.kind == const::L1MessageType_L2 || msg.kind == const::L1MessageType_L2ForGasEstimation) {
        // record the calldata usage, so it can be reported in tx receipt
        set msg.aggregator = Some(struct {
            aggregator: xif let Some(aggInfo) = msg.aggregator { aggInfo.aggregator } else { None<address> },
            calldataUnits: bytearray_getCalldataUnits(msg.msgData),
        });

        // it's an L2 message, so switch based on the L2 type
        let firstByte = bytearray_getByte(msg.msgData, 0);
        if (firstByte == const::L2MessageType_heartbeat) {
            // it's a heartbeat message, don't do anything
        } elseif (firstByte == const::L2MessageType_signedCompressedTx) {
            // it's a single message with compressed headers
            if let Some(txRequest) = decompressAndVerifyEcdsaSignedTx(msg.msgData, msg) {
                handleArrivingTx(txRequest);
            }
            // else signature was invalid, ignore msg
        } else {
            // subtype must be unsigned EOA, unsigned contract, or nonmutating
            if let Some(txRequest) = translateUnsignedTx(msg) {
                handleArrivingTx(txRequest);
            }
            // else request was malformatted, ignore it
        }
    } elseif (msg.kind == const::L1MessageType_rollupProtocolEvent) {
        // ignore this message type
    } elseif (msg.kind == const::L1MessageType_submitRetryableTx) {
        if let Some(txRequest) = processRetryableTx(msg) {
            handleArrivingTx(txRequest);
        }
        // submission failed, or no immediate tx included; either way, ignore the messge
    } else {
        // invalid message type -- ignore it
    }
}

impure func handleArrivingTx(tx: TxRequestData) {
    let (resultCode, request) = xif (allowedSenders_contains(tx.caller) || tx.incomingRequest.adminMode) {
        gasAccounting_prepareTx(tx)
    } else {
        (const::TxResultCode_senderNotPermitted, tx)
    };

    if (resultCode == const::TxResultCode_success) {
        if (processL2Request(request) == None<()>) {
            // reject for message format error
            emitTxReceipt(
                request.incomingRequest,
                const::TxResultCode_formatError,
                None<ByteArray>,
                None<EvmLogs>,
                None<GasUsage>,
                request.feeStats,
                false,      // don't emit tracing info because the tx was bogus
            );
        }
    } else {
        // before emitting a failure receipt, try to increment caller's sequence number
        if ((resultCode != const::TxResultCode_sequenceNumberTooLow) && (resultCode != const::TxResultCode_sequenceNumberTooHigh)) {
            if let Some(seqNum) = request.seqNum {
                let gAcctStore = safeGetGlobalAccountStore();
                if let Some(acct) = account_checkAndIncrSeqNum(accountStore_get(gAcctStore, request.caller), seqNum) {
                    safeSetGlobalAccountStore(accountStore_set(gAcctStore, request.caller, acct));
                }
            }
        }

        emitTxReceipt(
            request.incomingRequest,
            resultCode,
            None<ByteArray>,
            None<EvmLogs>,
            None<GasUsage>,
            request.feeStats,
            true,
        );
    }
}

impure func translateUnsignedTx(request: IncomingRequest) -> option<TxRequestData> {
    let inStream = bytestream_new(request.msgData);
    let (*inStream, subtype) = bytestream_getByte(inStream)?;
    let (*inStream, maxGas) = bytestream_get256(inStream)?;
    let (*inStream, gasPrice) = bytestream_get256(inStream)?;

    let seqNum = xif (subtype == const::L2MessageType_unsignedEOATx) {
        let (*inStream, sn) = bytestream_get256(inStream)?;
        Some(sn)
    } else {
        None<uint>
    };

    let (*inStream, destAddrAsUint) = bytestream_get256(inStream)?;
    let (*inStream, value) = bytestream_get256(inStream)?;
    let calldata = bytestream_getRemainingBytes(inStream);

    if (subtype == const::L2MessageType_unsignedEOATx) {
        set request.requestId = uint(hash(
            bytes32(request.sender),
            hash(bytes32(chainParams_chainId()), keccak256(request.msgData, 0, bytearray_size(request.msgData))),
        ));
    }
    return Some(
        struct {
            maxGas: maxGas,
            gasPrice: gasPrice,
            seqNum: seqNum,
            caller: request.sender,
            calleeAddr: address(destAddrAsUint),
            gasPayer: request.sender,
            value: value,
            calldata: calldata,
            nonMutating: (subtype == const::L2MessageType_nonmutatingCall),
            isConstructor: (destAddrAsUint == 0),
            incomingRequest: request,
            feeStats: txFeeStats_zero(),
            fromRetryable: None<RetryableTx>,
        }
    );
}

// below are specialized queue and queuestack types, to facilitate typechecking in the code above
// we can eliminate these if/when the Mini language supports generics

type IncomingRequestQueue = struct {
    q: Queue,
}

func incomingRequestQueue_new() -> IncomingRequestQueue {
    return struct { q: queue_new() };
}

func incomingRequestQueue_isEmpty(q: IncomingRequestQueue) -> bool {
    return queue_isEmpty(q.q);
}

func incomingRequestQueue_get(q: IncomingRequestQueue) -> option<(IncomingRequestQueue, IncomingRequest)> {
    let (uq, item) = queue_get(q.q)?;
    return Some((struct{ q: uq }, unsafecast<IncomingRequest>(item)));
}

func incomingRequestQueue_getOrDie(q: IncomingRequestQueue) -> (IncomingRequestQueue, IncomingRequest) {
    return xif let Some(res) = incomingRequestQueue_get(q) {
        res
    } else {
        error
    };
}

func incomingRequestQueue_put(q: IncomingRequestQueue, req: IncomingRequest) -> IncomingRequestQueue {
    return struct { q: queue_put(q.q, req) };
}

type IncomingRequestQueueStack = struct {
    qs: QueueStack,
}

func incomingRequestQueueStack_new() -> IncomingRequestQueueStack {
    return struct { qs: queuestack_new() };
}

func incomingRequestQueueStack_get(qs: IncomingRequestQueueStack) -> option<(IncomingRequestQueueStack, IncomingRequest)> {
    let (uqs, rawMsg) = queuestack_get(qs.qs)?;
    return Some((struct { qs: uqs }, unsafecast<IncomingRequest>(rawMsg)));
}

func incomingRequestQueueStack_push(qs: IncomingRequestQueueStack, q: IncomingRequestQueue) -> IncomingRequestQueueStack {
    return struct { qs: queuestack_push(qs.qs, q.q) };
}


type TxRequestQueue = struct {
    q: Queue,
}

func txRequestQueue_new() -> TxRequestQueue {
    return struct { q: queue_new() };
}

func txRequestQueue_get(q: TxRequestQueue) -> option<(TxRequestQueue, TxRequestData)> {
    let (uq, item) = queue_get(q.q)?;
    return Some((struct{ q: uq }, unsafecast<TxRequestData>(item)));
}
