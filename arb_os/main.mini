//
// Copyright 2020, Offchain Labs, Inc. All rights reserved.
//

use accounts::accountStore_init;
use accounts::getGlobalAccountStore;
use accounts::setGlobalAccountStore;
use accounts::accountStore_get;
use accounts::accountStore_set;
use accounts::accountStore_createAccountFromEvmCode;
use accounts::accountStore_upgradeContractFromEvmCode;
use accounts::accountStore_transferEthBalance;
use accounts::account_checkAndIncrSeqNum;
use accounts::account_setStorageCell;
use accounts::account_setNextSeqNum;
use accounts::pristineAccount;
use accounts::account_getBalance;
use accounts::account_setBalance;
use accounts::account_addBalance;

use arbstatistics::arbStatistics_init;

use arbsys::arbosVersion;

use blockhash::blockhash_init;

use chainParameters::chainParams_init;
use chainParameters::chainParams_haveDoneInit;
use chainParameters::chainParams_chainId;

use codeSegment::codeSegment_init;
use codeSegment::translateEvmCodeSegment;

use contractTemplates::getArbInfoCode;
use contractTemplates::getArbInfoAddress;
use contractTemplates::getArbInfoStorage;

use decompression::decompression_init;

use errorHandler::errorHandler_init;

use evmCallStack::evmCallStack_init;

use evmOps::evmOps_init;
use evmOps::dispatchForEvmOp;

use evmlogs::EvmLogs;

use gasAccounting::GasUsage;
use gasAccounting::gasAccounting_init;
use gasAccounting::getNextRequestFromCongestionAuction;

use inbox::inbox_init;
use inbox::emitGenesisBlockReceipt;

use messages::handleL2Request;

use output::output_init;
use output::txReceipts_init;
use output::emitTxReceipt;

use pluggables::pluggables_init;

use precompiles::precompiles_init;

use rollupTracker::rollupTracker_init;

use std::bytearray::ByteArray;
use std::bytearray::bytearray_unmarshalBytes;
use std::bytestream::bytestream_new;

use bridge_arbos_versions::GlobalsBeforeUpgrade;
use bridge_arbos_versions::remapGlobalsForUpgrade;

// The compiler will always put __fixedLocationGlobal in slot 0 of the AVM Register,
//     so we can rely on it not moving across upgrades.
var __fixedLocationGlobal: impure func(uint);    // points to EVM op dispatch function

impure func main(oldGlobals: GlobalsBeforeUpgrade) {
    if (unsafecast<any>(oldGlobals) != ()) {
        // this is an upgrade; we're inheriting the state of a previous ArbOS instance

        let (newGlobals, _oldArbosVersion) = remapGlobalsForUpgrade(oldGlobals);

        asm(newGlobals,) { rset };

        // now re-do the initializations that set up pointers into the ArbOS code
        errorHandler_init();
        evmOps_init();
        __fixedLocationGlobal = dispatchForEvmOp;
        codeSegment_init();

        if (initializePreinstalls(true) == None<()>) {
            panic;   // don't try to run without preinstalls and precompiles
        }

        // special-case fix for the WETH9 TransparentUpgradableProxy contract, on mainnet only
        if ((arbosVersion() == 33) && (chainParams_chainId() == 42161)) {
            let acctStore = getGlobalAccountStore();

            // transfer funds out of source account
            let xferFromAddr = address(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);
            let xferFromAcct = accountStore_get(acctStore, xferFromAddr);
            let balanceToXfer = account_getBalance(xferFromAcct);
            acctStore = accountStore_set(
                acctStore,
                xferFromAddr,
                account_setBalance(xferFromAcct, 0),
            );

            // destroy two old contracts, reset the accounts to pristine state
            let contractAddr1 = address(0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8);
            let contractAddr2 = address(0x82aF49447D8a07e3bd95BD0d56f35241523fBab1);
            acctStore = accountStore_set(acctStore, contractAddr1, pristineAccount(contractAddr1));
            acctStore = accountStore_set(acctStore, contractAddr2, pristineAccount(contractAddr2));

            // transfer the funds into the destination account
            let xferToAddr = address(0xBB1a241DCBd6A3894cB61F659034874Dc9CF65D4);
            let xferToAcct = accountStore_get(acctStore, xferToAddr);
            acctStore = accountStore_set(
                acctStore,
                xferToAddr,
                account_addBalance(xferToAcct, balanceToXfer),
            );

            // do another ETH rescue
            acctStore = xif let Some(uas) = accountStore_transferEthBalance(
                acctStore,
                address(0x4Dbd4fc535Ac27206064B68FfCf827b0A60BAB3f),
                address(0x1FcCBE3369eada96887A3b2857B57bBA65E83Dc1),
                account_getBalance(accountStore_get(acctStore, address(0x4Dbd4fc535Ac27206064B68FfCf827b0A60BAB3f))),
            ) {
                uas
            } else {
                // this shouldn't be possible, but be safe anyway
                acctStore
            };

            setGlobalAccountStore(acctStore);
        }
    } else {
        // this is a clean start, not an upgrade
        errorHandler_init();
        arbStatistics_init();

        pluggables_init();
        codeSegment_init();
        chainParams_init();
        output_init();
        decompression_init();
        inbox_init();
        gasAccounting_init();
        evmCallStack_init();
        evmOps_init();
        __fixedLocationGlobal = dispatchForEvmOp;
        blockhash_init();
        inbox_init();
        accountStore_init();
        txReceipts_init();
        rollupTracker_init();
        if (initializePreinstalls(false) == None<()>) {
            panic;   // don't try to run without preinstalls and precompiles
        }

        // advance the Arbitrum block number, and emit a block receipt
        emitGenesisBlockReceipt();
    }

    // initialize any customizations here

    mainRunLoop();
}

public impure func mainRunLoop() {
    loop {
        let (resultCode, request) = getNextRequestFromCongestionAuction();
        if (resultCode == const::TxResultCode_success) {
            if (handleL2Request(request) == None<()>) {
                // reject for message format error
                emitTxReceipt(
                    request.incomingRequest,
                    const::TxResultCode_formatError,
                    None<ByteArray>,
                    None<EvmLogs>,
                    None<GasUsage>,
                    request.feeStats,
                    false,      // don't emit tracing info because the tx was bogus
                );
            }
        } else {
            // before emitting a failure receipt, try to increment caller's sequence number
            if ( (resultCode != const::TxResultCode_sequenceNumberTooLow) && (resultCode != const::TxResultCode_sequenceNumberTooHigh) ) {
                if let Some(seqNum) = request.seqNum {
                    let gAcctStore = getGlobalAccountStore();
                    if let Some(acct) = account_checkAndIncrSeqNum(accountStore_get(gAcctStore, request.caller), seqNum) {
                        setGlobalAccountStore(accountStore_set(gAcctStore, request.caller, acct));
                    }
                }
            }

            emitTxReceipt(
                request.incomingRequest,
                resultCode,
                None<ByteArray>,
                None<EvmLogs>,
                None<GasUsage>,
                request.feeStats,
                true,
            );
        }
    }
}

impure func initializePreinstalls(isUpgrade: bool) -> option<()> {
    let acctStore = getGlobalAccountStore();

    let code = bytearray_unmarshalBytes(getArbInfoCode())?;
    let (initCodePt, evmJumpTable, _) = translateEvmCodeSegment(
        bytestream_new(code),
        false
    );
    acctStore = xif (isUpgrade) {
        accountStore_upgradeContractFromEvmCode(
            acctStore,
            getArbInfoAddress(),
            code,
            evmJumpTable,
            initCodePt,
        )
    } else {
        accountStore_createAccountFromEvmCode(
            acctStore,
            getArbInfoAddress(),
            code,
            evmJumpTable,
            initCodePt,
            getArbInfoStorage()
        )?
    };

    // set up precompiled contracts
    acctStore = precompiles_init(acctStore, isUpgrade)?;

    setGlobalAccountStore(acctStore);

    return Some(());
}
